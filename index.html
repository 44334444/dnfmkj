<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<meta name="description" content="Blocawa RGB-–ò–í–ï–ù–¢ ‚Äî —Å–µ–Ω—Å–æ—Ä–Ω–∞—è –∏–≥—Ä–∞ –≤ —Å—Ç–∏–ª–µ Block Blast —Å —Ä–∞–¥—É–∂–Ω–æ–π –∞–Ω–∏–º–∞—Ü–∏–µ–π –∏ –ø–∞—Å—Ö–∞–ª–∫–æ–π." />
<meta name="theme-color" content="#071021" />
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' rx='20' fill='%23071021'/><text x='50' y='70' font-size='80' text-anchor='middle' fill='%23fff'>üß©</text></svg>">
<title>Blocawa (RGB-–ò–í–ï–ù–¢)</title>
<style>
:root{
  --cell-size:36px;
  --gap:4px;
  --board-bg:#071021;
  --cell-bg:#0b1220;
  --cell-border:rgba(255,255,255,0.03);
}
*{box-sizing:border-box;-webkit-tap-highlight-color:transparent;}
html,body{height:100%;margin:0;font-family:Inter,Roboto,Arial,sans-serif;background:linear-gradient(180deg,#031220,#07182a);color:#e6eef6;-webkit-user-select:none;user-select:none;}
.wrap{display:flex;flex-direction:column;align-items:center;gap:14px;padding:14px;max-width:720px;margin:0 auto;}
h1{font-size:16px;font-weight:600;margin:8px 0 0;color:#cfeefe;text-shadow:0 2px 10px rgba(0,0,0,.6);}
.board-shell{background:rgba(255,255,255,.02);padding:14px;border-radius:14px;box-shadow:0 10px 40px rgba(2,6,23,.75);width:100%;}
.board{
  display:grid;
  grid-template-columns:repeat(10,var(--cell-size));
  grid-template-rows:repeat(10,var(--cell-size));
  gap:var(--gap);
  touch-action:none;
  justify-content:center;
}
.cell{
  width:var(--cell-size);
  height:var(--cell-size);
  background:var(--cell-bg);
  border-radius:8px;
  border:1px solid var(--cell-border);
  display:flex;align-items:center;justify-content:center;
  position:relative;overflow:hidden;transform-origin:center;
  transition:transform .12s ease,box-shadow .12s ease,opacity .12s ease;
}

/* rainbow background for occupied cells (—è—Ä—á–µ –Ω–∞ ~30%) */
.cell.occupied{
  animation:rainbowShift 4s linear infinite,popIn .22s cubic-bezier(.2,.9,.2,1);
  background:linear-gradient(90deg,rgba(255,0,110,.28),rgba(0,200,255,.28));
  border:1px solid rgba(255,255,255,.08);
  box-shadow:inset 0 -6px 18px rgba(0,0,0,.45),0 6px 16px rgba(0,0,0,.5);
}
.cell.occupied::after{
  content:'';
  position:absolute;inset:0;z-index:0;
  background:conic-gradient(from 90deg,#ff0055,#ff9900,#ffee33,#1fd9cc,#4b88ff,#ff00aa);
  opacity:.28;
  transform:scale(1.06);
  filter:blur(6px) brightness(1.25);
  animation:rotateHue 6s linear infinite;
  mix-blend-mode:overlay;
}
.cell .pulse{
  z-index:1;
  width:78%;height:78%;border-radius:6px;
  background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.02));
  transform:scale(.98);
}

.cell.highlight-okay{outline:3px solid rgba(16,185,129,.25);box-shadow:0 0 22px rgba(16,185,129,.12) inset;border-radius:8px;}
.cell.highlight-bad{outline:3px solid rgba(239,68,68,.28);box-shadow:0 0 22px rgba(239,68,68,.12) inset;border-radius:8px;}

.palette{display:flex;gap:12px;margin-top:12px;justify-content:center;flex-wrap:wrap;}
.piece{
  background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(0,0,0,.03));
  padding:8px;border-radius:12px;
  min-width:124px;display:flex;gap:10px;align-items:center;justify-content:center;
  touch-action:none;border:1px solid rgba(255,255,255,.03);
  transition:transform .16s ease,box-shadow .16s ease;
}
.piece.picked{transform:translateY(-6px) scale(1.03);box-shadow:0 14px 40px rgba(2,6,23,.7);}
.mini-grid{display:grid;gap:4px;}
.mini-cell{width:14px;height:14px;border-radius:3px;background:rgba(255,255,255,.05);box-shadow:inset 0 -2px 6px rgba(0,0,0,.45);}
.mini-cell.filled{background:linear-gradient(180deg,#ff7aa2,#8affd1);box-shadow:0 4px 10px rgba(2,6,8,.6);}

.ghost{position:fixed;pointer-events:none;z-index:9999;transform:translate(-50%,-50%);opacity:.95;filter:drop-shadow(0 12px 30px rgba(2,6,23,.6));border-radius:10px;transition:transform .08s linear;}
.controls{display:flex;gap:8px;margin-top:8px;align-items:center;justify-content:center;flex-wrap:wrap;}
button{padding:8px 10px;border-radius:8px;border:0;background:#0b1220;color:#dff7f0;font-weight:700;cursor:pointer;box-shadow:0 6px 18px rgba(2,6,23,.6);}
.score{margin-left:8px;color:#9ee7d6;font-weight:800;font-size:15px;}

.cell.clearing{animation:clearFade .42s cubic-bezier(.2,.9,.2,1) forwards;}
.cell.placed{animation:placePop .28s cubic-bezier(.2,.9,.2,1);box-shadow:0 10px 30px rgba(0,0,0,.6) inset,0 14px 40px rgba(0,0,0,.5);}

@keyframes rainbowShift{0%{filter:hue-rotate(0deg);}100%{filter:hue-rotate(360deg);}}
@keyframes rotateHue{0%{transform:rotate(0deg);}100%{transform:rotate(360deg);}}
@keyframes popIn{0%{transform:scale(.6);opacity:0}70%{transform:scale(1.05);}100%{transform:scale(1);opacity:1}}
@keyframes clearFade{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(.6)}}
@keyframes placePop{0%{transform:scale(.6);opacity:0}60%{transform:scale(1.08);}100%{transform:scale(1);opacity:1}}
@keyframes slideUp{0%{transform:translateX(-50%) translateY(80px);opacity:0;}60%{transform:translateX(-50%) translateY(-8px);opacity:1;}100%{transform:translateX(-50%) translateY(0);}}
/* particle */
.particle{
  position:absolute;border-radius:50%;pointer-events:none;z-index:5000;opacity:0.95;
  transform:scale(.2);
  animation:particleMove .8s cubic-bezier(.2,.9,.2,1) forwards;
}
@keyframes particleMove{0%{transform:translate(0,0) scale(.2);opacity:1}100%{transform:translate(var(--tx), var(--ty)) scale(1);opacity:0}}

.easter{
  position:fixed;left:50%;bottom:-160px;transform:translateX(-50%);
  background:linear-gradient(180deg,#0a1318,#07101a);
  padding:18px 26px;border-radius:18px;z-index:2000;border:1px solid rgba(255,255,255,.06);
  box-shadow:0 20px 60px rgba(2,6,23,.75);
  display:flex;gap:10px;align-items:center;color:#fff;font-weight:800;letter-spacing:.6px;opacity:0;
}
.easter.show{animation:slideUp 1s cubic-bezier(.2,.9,.2,1) forwards;}
.easter .label{font-size:20px;color:#ffd36b;text-shadow:0 4px 30px rgba(255,211,107,.12);}
.easter .sub{font-size:14px;color:#bfe9d7;}

@media(max-width:420px){
  :root{--cell-size:30px;--gap:3px}
  .mini-cell{width:12px;height:12px}
  .easter{padding:14px 18px}
  .easter .label{font-size:18px}
  .piece{min-width:90px;padding:6px}
  .controls{gap:6px}
  button{padding:10px 12px;font-size:15px}
}
</style>
</head>
<body>
<noscript>
  <div style="text-align:center;padding:2em;font-size:18px;color:#fff;">
    ‚ö†Ô∏è –î–ª—è –∑–∞–ø—É—Å–∫–∞ –∏–≥—Ä—ã –≤–∫–ª—é—á–∏—Ç–µ JavaScript.
  </div>
</noscript>

<div class="wrap">
  <h1>Blocawa ‚Äî RGB-–ò–í–ï–ù–¢</h1>
  <div class="board-shell" id="boardShell">
    <div id="board" class="board" aria-label="–ò–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ"></div>
    <div class="palette" id="palette" aria-hidden="false"></div>
    <div class="controls">                                  
      <div class="score">–û—á–∫–∏: <span id="score">0</span></div>
    </div>

    <!-- leaderboard placeholder added -->
    <div id="leaderContainer" style="margin-top:12px;text-align:center;">
      <h3 style="margin:6px 0;color:#8ae7d1;font-size:14px;">üèÜ –¢–æ–ø-3</h3>
      <ol id="leaderboard" style="list-style:none;padding:0;margin:0 0 6px 0;"></ol>
      <div style="font-size:12px;color:#cfeefe;opacity:.8;">–ù–∏–∫ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –≤ LocalStorage</div>
    </div>
  </div>
</div>

<!-- Easter egg element -->
<div id="easter" class="easter" aria-hidden="true">
  <div class="label">—É–¥–æ–±–Ω–∞—è –ø–æ–∑–∞</div>
  <div class="sub">‚Äî –∏—Ä–∞ –ø–∞—Å—Ö–∞–ª–∫–æ ‚Äî</div>
</div>

<script>
/* --- –ò–°–•–û–î–ù–´–ô –ö–û–î –ò–ì–†–´ (–Ω–µ –∏–∑–º–µ–Ω—ë–Ω) --- */
/* –ü–æ–ª–Ω—ã–π JS: –ª–æ–≥–∏–∫–∞ –∏–≥—Ä–æ–≤–æ–≥–æ –ø–æ–ª—è, –ø–∞–ª–∏—Ç—Ä—ã, drag/tap, –æ—á–∏—Å—Ç–∫–∏ –∏ –ø–∞—Å—Ö–∞–ª–∫–∏. */
/* –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã */
const COLS = 10, ROWS = 10;
const boardEl = document.getElementById('board');
const paletteEl = document.getElementById('palette');
const scoreEl = document.getElementById('score');
const newPiecesBtn = document.getElementById('newPiecesBtn');
const easterEl = document.getElementById('easter');

let board = Array.from({length: ROWS}, ()=>Array(COLS).fill(0));
let score = 0;

/* –ù–∞–±–æ—Ä —Ñ–∏–≥—É—Ä ‚Äî —Å–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω –∏ –≥–æ—Ç–æ–≤ –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é */
const SHAPES = [
  [[0,0]], // single
  [[0,0],[1,0]], // 2-line
  [[0,0],[1,0],[2,0]], // 3-line
  [[0,0],[0,1],[1,0]], // small L (2x2 L)
  [[0,0],[1,0],[0,1],[1,1]], // 2x2 square
  [[0,0],[1,0],[2,0],[3,0]], // 4-line
  [[0,0],[1,0],[2,0],[1,1]], // T (upright)
  [[1,0],[0,1],[1,1],[2,1],[1,2]], // plus (5)
  [[0,0],[1,0],[2,0],[2,1]], // L-like longer
  [[0,0],[0,1],[0,2],[1,2]], // mirrored L
  [[0,1],[1,1],[2,1],[1,0]], // T variant (centered)
  [[0,0],[1,0],[1,1]], // small corner
  [[0,0],[1,0],[2,0],[0,1]] // –ì-–æ–±—Ä–∞–∑–Ω—ã–π
];

/* --- –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –¥–æ—Å–∫–∏ --- */
function renderBoard(){
  boardEl.innerHTML = '';
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.r = r;
      cell.dataset.c = c;
      if(board[r][c]){
        cell.classList.add('occupied');
        const inner = document.createElement('div');
        inner.className = 'pulse';
        cell.appendChild(inner);
      }
      boardEl.appendChild(cell);
    }
  }
}
renderBoard();

/* --- –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–ª—É—á–∞–π–Ω–æ–π —Ñ–∏–≥—É—Ä—ã --- */
function randomPiece(){
  const shape = SHAPES[Math.floor(Math.random()*SHAPES.length)];
  // Normalize so min x,y = 0
  let minx = Math.min(...shape.map(p=>p[0])), miny = Math.min(...shape.map(p=>p[1]));
  const coords = shape.map(p=>[p[0]-minx, p[1]-miny]);
  return {coords, id: Math.random().toString(36).slice(2,8)};
}

/* --- –ü–∞–ª–∏—Ç—Ä–∞ --- */
let palette = [];
function refillPalette(){
  palette = [randomPiece(), randomPiece(), randomPiece()];
  renderPalette();
}
refillPalette();

function renderPalette(){
  paletteEl.innerHTML = '';
  for(let i=0;i<palette.length;i++){
    const p = palette[i];
    const pieceEl = document.createElement('div');
    pieceEl.className = 'piece';
    pieceEl.dataset.pieceId = p.id;
    pieceEl.setAttribute('role','button');

    // compute bounds
    const maxX = Math.max(...p.coords.map(cc=>cc[0]));
    const maxY = Math.max(...p.coords.map(cc=>cc[1]));
    const cols = maxX+1, rows = maxY+1;
    const mini = document.createElement('div');
    mini.className = 'mini-grid';
    mini.style.gridTemplateColumns = `repeat(${cols}, 14px)`;
    mini.style.gridAutoRows = `14px`;
    mini.style.padding = '6px';
    mini.style.borderRadius = '8px';
    mini.style.background = 'linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.01))';

    for(let y=0;y<rows;y++){
      for(let x=0;x<cols;x++){
        const mc = document.createElement('div');
        const filled = p.coords.some(pt=>pt[0]===x && pt[1]===y);
        mc.className = 'mini-cell' + (filled? ' filled':'');
        if(filled) mc.style.background = 'linear-gradient(180deg,#ff7aa2,#8affd1)';
        mini.appendChild(mc);
      }
    }
    pieceEl.appendChild(mini);
    paletteEl.appendChild(pieceEl);
    attachPiecePointerHandlers(pieceEl, p);
  }
}

/* --- Drag / Tap state --- */
let currentPick = null;
let ghost = null;

function createGhostForPiece(piece){
  const g = document.createElement('div');
  g.className = 'ghost';
  // build grid reflective of bounding box
  const maxX = Math.max(...piece.coords.map(p=>p[0]));
  const maxY = Math.max(...piece.coords.map(p=>p[1]));
  const cols = maxX+1, rows = maxY+1;
  g.style.display = 'grid';
  const cellBase = Math.max(20, Math.round(parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell-size'))*0.9));
  g.style.gridTemplateColumns = `repeat(${cols}, ${cellBase}px)`;
  g.style.gridAutoRows = `${cellBase}px`;
  g.style.gap = Math.max(3, Math.round(parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap'))*0.6)) + 'px';
  g.style.padding = '6px';
  g.style.borderRadius = '10px';
  g.style.background = 'rgba(0,0,0,0.22)';
  g.style.border = '1px solid rgba(255,255,255,0.04)';

  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      const box = document.createElement('div');
      box.style.borderRadius = '6px';
      box.style.boxShadow = 'inset 0 -3px 8px rgba(0,0,0,0.6)';
      if(piece.coords.some(pt=>pt[0]===x && pt[1]===y)){
        box.style.background = 'linear-gradient(180deg,#ff9ad1,#7df0c2)';
        box.style.opacity = '0.98';
      } else {
        box.style.background = 'transparent';
      }
      g.appendChild(box);
    }
  }

  document.body.appendChild(g);
  return g;
}

function attachPiecePointerHandlers(el, piece){
  el.addEventListener('pointerdown', (e)=>{
    e.preventDefault();
    el.setPointerCapture(e.pointerId);
    currentPick = {
      piece,
      pointerId: e.pointerId,
      originEl: el,
      startX: e.clientX,
      startY: e.clientY,
      moved: false
    };
    el.classList.add('picked');
    ghost = createGhostForPiece(piece);
    moveGhost(e.clientX, e.clientY);
    window.addEventListener('pointermove', onGlobalPointerMove);
    window.addEventListener('pointerup', onGlobalPointerUp);
  });
}

function onGlobalPointerMove(e){
  if(!currentPick || e.pointerId !== currentPick.pointerId) return;
  const dx = e.clientX - currentPick.startX, dy = e.clientY - currentPick.startY;
  if(!currentPick.moved && (Math.abs(dx)>6 || Math.abs(dy)>6)){
    currentPick.moved = true;
  }
  moveGhost(e.clientX, e.clientY);

  // highlight cell under pointer
  const boardRect = boardEl.getBoundingClientRect();
  const cellW = boardRect.width / COLS;
  const cellH = boardRect.height / ROWS;
  const relX = e.clientX - boardRect.left;
  const relY = e.clientY - boardRect.top;
  const baseCol = Math.floor(relX / cellW);
  const baseRow = Math.floor(relY / cellH);
  clearHighlights();
  if(baseCol>=0 && baseCol<COLS && baseRow>=0 && baseRow<ROWS){
    const ok = checkPlacement(currentPick.piece.coords, baseRow, baseCol);
    highlightPlacement(currentPick.piece.coords, baseRow, baseCol, ok);
  }
}

function onGlobalPointerUp(e){
  if(!currentPick || e.pointerId !== currentPick.pointerId) return;
  const boardRect = boardEl.getBoundingClientRect();
  const cellW = boardRect.width / COLS;
  const cellH = boardRect.height / ROWS;
  const relX = e.clientX - boardRect.left;
  const relY = e.clientY - boardRect.top;
  const baseCol = Math.floor(relX / cellW);
  const baseRow = Math.floor(relY / cellH);

  if(currentPick.moved){
    if(baseCol>=0 && baseCol<COLS && baseRow>=0 && baseRow<ROWS){
      attemptPlace(currentPick.piece, baseRow, baseCol);
    }
  } else {
    enterTapToPlaceMode(currentPick.piece, currentPick.originEl);
  }
  cleanupCurrentPick();
}

function cleanupCurrentPick(){
  if(currentPick && currentPick.originEl) currentPick.originEl.classList.remove('picked');
  if(ghost){ ghost.remove(); ghost = null; }
  currentPick = null;
  window.removeEventListener('pointermove', onGlobalPointerMove);
  window.removeEventListener('pointerup', onGlobalPointerUp);
  clearHighlights();
}

function moveGhost(clientX, clientY){
  if(!ghost) return;
  ghost.style.left = clientX + 'px';
  ghost.style.top = clientY + 'px';
}

/* --- –ü—Ä–æ–≤–µ—Ä–∫–∏ –∏ –ø–æ–¥—Å–≤–µ—Ç–∫–∞ --- */
function checkPlacement(coords, row, col){
  for(const [x,y] of coords){
    const r = row + y; const c = col + x;
    if(r<0 || r>=ROWS || c<0 || c>=COLS) return false;
    if(board[r][c]) return false;
  }
  return true;
}

function highlightPlacement(coords, row, col, ok){
  coords.forEach(([x,y])=>{
    const r = row + y, c = col + x;
    if(r<0 || r>=ROWS || c<0 || c>=COLS) return;
    const idx = r*COLS + c;
    const cell = boardEl.children[idx];
    if(!cell) return;
    cell.classList.add(ok ? 'highlight-okay' : 'highlight-bad');
  });
}

function clearHighlights(){
  boardEl.querySelectorAll('.cell.highlight-okay, .cell.highlight-bad').forEach(el=>{
    el.classList.remove('highlight-okay','highlight-bad');
  });
}

/* --- –†–∞–∑–º–µ—â–µ–Ω–∏–µ —Ñ–∏–≥—É—Ä—ã --- */
function attemptPlace(piece, row, col){
  if(!checkPlacement(piece.coords, row, col)){
    if(navigator.vibrate) navigator.vibrate(32);
    flashBadPlacement();
    playSound('error');
    return false;
  }
  // mark newly placed cells for particle & animation
  const newly = [];
  piece.coords.forEach(([x,y])=>{
    const r = row + y, c = col + x;
    board[r][c] = 1;
    newly.push([r,c]);
  });
  renderBoard();
  // animate placed cells
  animatePlacedCells(newly);
  palette = palette.filter(p=>p.id !== piece.id);
  if(palette.length===0) refillPalette();
  renderPalette();
  // score: –±–∞–∑–æ–≤—ã–µ –æ—á–∫–∏ + –±–æ–Ω—É—Å—ã –∑–∞ —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ
  score += piece.coords.length * 10;
  scoreEl.textContent = score;
  playSound('place');

  // –ü–∞—Å—Ö–∞–ª–∫–∞: —Ä–æ–≤–Ω–æ 69000
  if(score === 69000) showEasterEgg();

  // –ø—Ä–æ–≤–µ—Ä–∫–∞ –∏ –æ—á–∏—Å—Ç–∫–∞ –ª–∏–Ω–∏–π
  const cleared = clearFullLines();
  if(cleared > 0){
    // –±–æ–Ω—É—Å –∑–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –ª–∏–Ω–∏–∏
    score += cleared * 50;
    scoreEl.textContent = score;
    playSound('clear');
    if(score === 69000) showEasterEgg();
  }

  return true;
}

function flashBadPlacement(){
  // –Ω–µ–±–æ–ª—å—à–æ–π –≤–∏–∑—É–∞–ª—å–Ω—ã–π —Ñ–ª–µ—à –≤—Å–µ—Ö –∫–ª–µ—Ç–æ–∫
  boardEl.style.transition = 'transform 80ms ease';
  boardEl.style.transform = 'translateY(-6px)';
  setTimeout(()=>{ boardEl.style.transform = ''; }, 90);
}

/* --- Tap-to-place mode --- */
let tapMode = null;
function enterTapToPlaceMode(piece, originEl){
  tapMode = {piece, originEl};
  originEl.classList.add('picked');
  const handler = function(e){
    e.preventDefault();
    const target = e.target;
    if(!target.classList.contains('cell')) return;
    const r = Number(target.dataset.r), c = Number(target.dataset.c);
    attemptPlace(piece, r, c);
    originEl.classList.remove('picked');
    tapMode = null;
    boardEl.removeEventListener('pointerdown', handler);
  };
  boardEl.addEventListener('pointerdown', handler);
}

/* --- –û—á–∏—Å—Ç–∫–∞ –ø–æ–ª–Ω—ã—Ö —Å—Ç—Ä–æ–∫/—Å—Ç–æ–ª–±—Ü–æ–≤ --- */
function clearFullLines(){
  const fullRows = [];
  for(let r=0;r<ROWS;r++) if(board[r].every(v=>v===1)) fullRows.push(r);
  const fullCols = [];
  for(let c=0;c<COLS;c++){
    let ok = true;
    for(let r=0;r<ROWS;r++) if(board[r][c]===0){ ok=false; break; }
    if(ok) fullCols.push(c);
  }
  if(fullRows.length===0 && fullCols.length===0) return 0;

  // –î–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏ –ø–æ–º–µ—Ç–∏–º –∫–ª–µ—Ç–∫–∏ –∫–∞–∫ clearing, –∑–∞—Ç–µ–º —É–¥–∞–ª–∏–º
  const toClearCells = [];
  fullRows.forEach(r=>{
    for(let c=0;c<COLS;c++){
      toClearCells.push([r,c]);
    }
  });
  fullCols.forEach(c=>{
    for(let r=0;r<ROWS;r++){
      // avoid double push
      if(!toClearCells.some(pair=>pair[0]===r && pair[1]===c)) toClearCells.push([r,c]);
    }
  });

  // –ø–æ–º–µ—Ç–∏–º DOM-—ç–ª–µ–º–µ–Ω—Ç—ã
  toClearCells.forEach(([r,c])=>{
    const idx = r*COLS + c;
    const el = boardEl.children[idx];
    if(el) el.classList.add('clearing');
  });

  // –ø–æ–¥–æ–∂–¥—ë–º –∞–Ω–∏–º–∞—Ü–∏—é, –∑–∞—Ç–µ–º –æ—á–∏—Å—Ç–∏–º data model –∏ –ø–µ—Ä–µ—Ä–µ–Ω–¥–µ—Ä–∏–º
  setTimeout(()=>{
    // –æ—á–∏—Å—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö
    fullRows.forEach(r=>{ for(let c=0;c<COLS;c++) board[r][c]=0; });
    fullCols.forEach(c=>{ for(let r=0;r<ROWS;r++) board[r][c]=0; });
    renderBoard();
  }, 420);

  // –æ—á–∫–∏
  const clearedCount = fullRows.length + fullCols.length;
  score += clearedCount * 100; // –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –Ω–∞–≥—Ä–∞–¥–∞
  scoreEl.textContent = score;
  return clearedCount;
}

/* --- –ù–æ–≤—ã–µ —Ñ–∏–≥—É—Ä—ã --- */
if(newPiecesBtn) newPiecesBtn.addEventListener('click', ()=>{ refillPalette(); });

/* --- –û—Ç–∫–ª—é—á–µ–Ω–∏–µ —Å–∫—Ä–æ–ª–ª–∞ –ø—Ä–∏ —Ç–∞—á–µ –≤–Ω—É—Ç—Ä–∏ –ø–æ–ª—è --- */
document.addEventListener('touchmove', function(e){
  if(e.target.closest('.board-shell')) e.preventDefault();
}, {passive:false});

/* --- –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –∫–ª–∏–∫–∞ –¥–ª—è tap mode (–¥–µ—Å–∫—Ç–æ–ø) --- */
boardEl.addEventListener('click', (e)=>{
  if(tapMode && e.target.classList.contains('cell')){
    const r = Number(e.target.dataset.r), c = Number(e.target.dataset.c);
    attemptPlace(tapMode.piece, r, c);
    if(tapMode.originEl) tapMode.originEl.classList.remove('picked');
    tapMode = null;
  }
});

/* --- –ü–∞—Å—Ö–∞–ª–∫–∞: "—É–¥–æ–±–Ω–∞—è –ø–æ–∑–∞" --- */
let easterShown = false;
function showEasterEgg(){
  if(easterShown) return;
  easterShown = true;
  easterEl.classList.add('show');
  easterEl.setAttribute('aria-hidden','false');
  // —Å–∫—Ä—ã—Ç—å —á–µ—Ä–µ–∑ 5.5 —Å–µ–∫
  setTimeout(()=>{
    easterEl.classList.remove('show');
    easterEl.setAttribute('aria-hidden','true');
  }, 5500);
}

/* --- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è --- */
renderBoard();
renderPalette();

  /* ================= –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏–≥—Ä—ã –≤ cookie ================= */

function setCookie(name, value, days=365) {
  const date = new Date();
  date.setTime(date.getTime() + (days*24*60*60*1000));
  const expires = "expires=" + date.toUTCString();
  document.cookie = name + "=" + value + ";" + expires + ";path=/";
}

function getCookie(name) {
  const n = name + "=";
  const decodedCookie = decodeURIComponent(document.cookie);
  const ca = decodedCookie.split(';');
  for(let i=0;i<ca.length;i++) {
    let c = ca[i];
    while(c.charAt(0)==' ') c = c.substring(1);
    if(c.indexOf(n)==0) return c.substring(n.length, c.length);
  }
  return "";
}

function saveGame() {
  const data = {
    board,
    score,
    paletteCoords: palette.map(p=>p.coords),
    paletteIds: palette.map(p=>p.id)
  };
  const encoded = btoa(JSON.stringify(data));
  setCookie("blocawa_save", encoded, 365);
}

function loadGame() {
  const raw = getCookie("blocawa_save");
  if(!raw) return false;
  try {
    const data = JSON.parse(atob(raw));
    board = data.board || board;
    score = data.score || 0;
    palette = (data.paletteCoords||[]).map((coords,i)=>({
      coords, id: data.paletteIds[i] || Math.random().toString(36).slice(2,8)
    }));
    renderBoard();
    renderPalette();
    scoreEl.textContent = score;
    return true;
  } catch(e){
    console.warn("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è:", e);
    return false;
  }
}

/* –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ */
setInterval(saveGame, 3000);

/* –ü—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã */
if(!loadGame()){
  renderBoard();
  renderPalette();
}

/* --- –ö–û–ù–ï–¶ –ò–°–•–û–î–ù–û–ì–û –ö–û–î–ê --- */
</script>

<script type="module">
  // Import the functions you need from the SDKs you need
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-app.js";
  import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-analytics.js";
  // TODO: Add SDKs for Firebase products that you want to use
  // https://firebase.google.com/docs/web/setup#available-libraries

  // Your web app's Firebase configuration
  // For Firebase JS SDK v7.20.0 and later, measurementId is optional
  const firebaseConfig = {
    apiKey: "AIzaSyApwYCoo-JVIIl3DK1EQhKWfFDsW8PF4nE",
    authDomain: "rewgfsdf.firebaseapp.com",
    databaseURL: "https://rewgfsdf-default-rtdb.europe-west1.firebasedatabase.app",
    projectId: "rewgfsdf",
    storageBucket: "rewgfsdf.firebasestorage.app",
    messagingSenderId: "1028773799521",
    appId: "1:1028773799521:web:bc7b2ab93ba6513e996c20",
    measurementId: "G-T0FBTEME7N"
  };

  // Initialize Firebase
  const app = initializeApp(firebaseConfig);
  const analytics = getAnalytics(app);
  
</script>

let firebaseEnabled = false;
let db = null;
try {
  const app = initializeApp(firebaseConfig);
  db = getDatabase(app);
  firebaseEnabled = true;
  console.log("Firebase –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω");
} catch(e){
  console.warn("Firebase –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω ‚Äî –ø—Ä–æ–≤–µ—Ä—å –∫–æ–Ω—Ñ–∏–≥.", e);
}

/* ---------------- WebAudio: –∑–≤—É–∫–∏ place/clear/error ---------------- */
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;
function ensureAudio(){
  if(!audioCtx) audioCtx = new AudioCtx();
}
function playTone(freq, duration=0.08, type='sine', vol=0.08){
  try{
    ensureAudio();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type;
    o.frequency.value = freq;
    g.gain.value = vol;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);
    setTimeout(()=>{ o.stop(); }, duration*1000 + 20);
  }catch(e){ /* audio blocked */ }
}
function playSound(kind){
  if(kind === 'place') {
    playTone(780, 0.08, 'triangle', 0.06);
    playTone(980, 0.09, 'sine', 0.04);
  } else if(kind === 'clear'){
    playTone(1000, 0.16, 'sine', 0.10);
    setTimeout(()=>playTone(620,0.12,'sine',0.06), 60);
  } else if(kind === 'error'){
    playTone(240, 0.12, 'sawtooth', 0.12);
  }
}

/* ----------------- Particle effect + placed animation ----------------- */
function animatePlacedCells(cells){
  // cells = [[r,c], ...]
  cells.forEach(([r,c])=>{
    const idx = r*COLS + c;
    const el = boardEl.children[idx];
    if(!el) return;
    // add class for pop animation
    el.classList.add('placed');
    setTimeout(()=> el.classList.remove('placed'), 420);

    // spawn small particles
    for(let i=0;i<6;i++){
      const p = document.createElement('div');
      p.className = 'particle';
      const size = Math.random()*8 + 6;
      p.style.width = p.style.height = size + 'px';
      p.style.left = (el.getBoundingClientRect().left + el.clientWidth/2 - size/2) + 'px';
      p.style.top = (el.getBoundingClientRect().top + el.clientHeight/2 - size/2) + 'px';
      p.style.background = ['#ff7aa2','#8affd1','#ffd36b','#7df0c2'][Math.floor(Math.random()*4)];
      // random translate
      const tx = (Math.random()*160 - 80).toFixed(0) + 'px';
      const ty = (Math.random()*120 - 100).toFixed(0) + 'px';
      p.style.setProperty('--tx', tx);
      p.style.setProperty('--ty', ty);
      document.body.appendChild(p);
      setTimeout(()=> p.remove(), 820);
    }
  });
}

/* ----------------- Mobile tweak: adjust --cell-size based on viewport ----------------- */
function adaptCellSize(){
  const w = Math.min(window.innerWidth, 720);
  let sizeVar = 36;
  if(w <= 420) sizeVar = 30;
  else if(w <= 360) sizeVar = 28;
  else if(w >= 900) sizeVar = 44;
  document.documentElement.style.setProperty('--cell-size', sizeVar + 'px');
}
adaptCellSize();
window.addEventListener('resize', adaptCellSize);

/* ----------------- PLAYER NAME (localStorage) ----------------- */
const PLAYER_KEY = 'blocawa_nick_v1';
let playerName = localStorage.getItem(PLAYER_KEY);
if(!playerName){
  playerName = prompt("–í–≤–µ–¥–∏—Ç–µ –Ω–∏–∫ –¥–ª—è —Ç–∞–±–ª–∏—Ü—ã –ª–∏–¥–µ—Ä–æ–≤ (–±–µ–∑ –ø—Ä–æ–±–µ–ª–æ–≤):") || ('Player' + Math.floor(Math.random()*9000+100));
  playerName = playerName.replace(/\s+/g,'_').slice(0,24);
  localStorage.setItem(PLAYER_KEY, playerName);
}

/* ----------------- Firebase Save/Load helpers ----------------- */
async function saveProgressToFirebase(){
  if(!firebaseEnabled) return;
  try{
    const saveRef = ref(db, 'saves/' + playerName);
    await set(saveRef, {
      board,
      score,
      paletteCoords: palette.map(p=>p.coords),
      paletteIds: palette.map(p=>p.id),
      updated: new Date().toISOString()
    });
    // also update leaderboard node
    const playerRef = ref(db, 'players/' + playerName);
    await set(playerRef, { name: playerName, score: score, updated: new Date().toISOString() });
    //console.log('Saved to firebase');
  }catch(e){
    console.warn('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ Firebase:', e);
  }
}

async function loadProgressFromFirebase(){
  if(!firebaseEnabled) return false;
  try{
    const dbRef = ref(db);
    const snap = await get(child(dbRef, 'saves/' + playerName));
    if(snap.exists()){
      const data = snap.val();
      if(data.board) board = data.board;
      if(typeof data.score === 'number') score = data.score;
      if(data.paletteCoords){
        palette = (data.paletteCoords||[]).map((coords,i)=>({
          coords, id: data.paletteIds ? data.paletteIds[i] : (Math.random().toString(36).slice(2,8))
        }));
      }
      renderBoard();
      renderPalette();
      scoreEl.textContent = score;
      console.log('Loaded progress from Firebase for', playerName);
      return true;
    }
  }catch(e){
    console.warn('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ –∏–∑ Firebase:', e);
  }
  return false;
}

/* ----------------- Leaderboard (top 3) ----------------- */
function startLeaderboardListener(){
  if(!firebaseEnabled) return;
  const topQuery = query(ref(db, 'players'), orderByChild('score'), limitToLast(3));
  onValue(topQuery, (snapshot)=>{
    const data = snapshot.val() || {};
    const arr = Object.values(data).sort((a,b)=>b.score - a.score);
    const list = document.getElementById('leaderboard');
    if(!list) return;
    list.innerHTML = '';
    arr.forEach((p, i)=>{
      const li = document.createElement('li');
      li.style.padding = '6px 10px';
      li.style.margin = '4px 6px';
      li.style.borderRadius = '8px';
      li.style.background = 'linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.02))';
      li.textContent = `${i+1}. ${p.name} ‚Äî ${p.score}`;
      list.appendChild(li);
    });
  }, (err)=> console.warn('leader error', err));
}

/* ----------------- Hooking into game updates WITHOUT changing logic ----------------- */
/* Approach: observe score element and intercept renderBoard calls to trigger firebase save and animate newly placed cells */
(function attachHooks(){
  // 1) Observe score changes
  const scoreObserver = new MutationObserver(muts=>{
    // whenever score text changes, save small delay to avoid frequent writes
    scheduleSaveToFirebaseDebounced();
  });
  scoreObserver.observe(scoreEl, { characterData: true, childList: true, subtree: true });

  // 2) Wrap renderBoard to detect newly occupied cells and animate them and schedule save
  if(typeof renderBoard === 'function'){
    const originalRender = renderBoard;
    let prevBoardSnapshot = JSON.parse(JSON.stringify(board));
    renderBoard = function(){
      // take snapshot before
      const before = JSON.parse(JSON.stringify(prevBoardSnapshot));
      originalRender();
      // compute newly filled cells
      const newly = [];
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          if(board[r][c] && !before[r][c]) newly.push([r,c]);
        }
      }
      if(newly.length) animatePlacedCells(newly);
      prevBoardSnapshot = JSON.parse(JSON.stringify(board));
      // schedule save after render
      scheduleSaveToFirebaseDebounced();
    };
  }

  // On initial load, try loading user's last progress from Firebase
  (async ()=>{
    const loaded = await loadProgressFromFirebase();
    if(!loaded){
      // nothing loaded ‚Äî but ensure leaderboard listener still runs
      // render already called earlier
    }
    if(firebaseEnabled) startLeaderboardListener();
  })();

})();

/* ----------------- Debounced saves to reduce writes ----------------- */
let saveTimeout = null;
function scheduleSaveToFirebaseDebounced(delay=1200){
  if(!firebaseEnabled) return;
  if(saveTimeout) clearTimeout(saveTimeout);
  saveTimeout = setTimeout(()=>{
    saveProgressToFirebase();
    saveTimeout = null;
  }, delay);
}

/* ----------------- Manual save button (optional) ----------------- */
const leaderContainer = document.getElementById('leaderContainer');
if(leaderContainer){
  const btn = document.createElement('button');
  btn.textContent = '–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤ –æ–±–ª–∞–∫–æ';
  btn.style.marginTop = '8px';
  btn.onclick = ()=> saveProgressToFirebase().then(()=> alert('–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ –≤ Firebase'));
  leaderContainer.appendChild(btn);
}

/* ----------------- Also save cookie/local backup on score change ----------------- */
(function backupLocalOnScoreChange(){
  const observer = new MutationObserver(()=> saveGame());
  observer.observe(scoreEl, { childList: true, subtree: true });
})();

/* ----------------- Touch improvements: increase pointer area on mobile for palette pieces ----------------- */
function improveTouchAreas(){
  document.querySelectorAll('.piece').forEach(p=>{
    p.style.touchAction = 'manipulation';
    p.style.padding = '10px';
  });
}
setTimeout(improveTouchAreas, 500);

/* ----------------- Ensure audio resumes on user gesture (mobile browsers often block auto audio) ----------------- */
document.addEventListener('pointerdown', function resumeAudio(){
  if(audioCtx && audioCtx.state === 'suspended') {
    audioCtx.resume().catch(()=>{});
  }
  document.removeEventListener('pointerdown', resumeAudio);
});

/* ----------------- If Firebase is not configured, show small notice in console ----------------- */
if(!firebaseEnabled){
  console.warn('Firebase –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω ‚Äî –≤—Å—Ç–∞–≤—å –∫–æ–Ω—Ñ–∏–≥ –≤ —Å–∫—Ä–∏–ø—Ç, —á—Ç–æ–±—ã –≤–∫–ª—é—á–∏—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∏ —Ç–∞–±–ª–∏—Ü—É –ª–∏–¥–µ—Ä–æ–≤.');
}
</script>

</body>
</html>
